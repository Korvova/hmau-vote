/**
 * –¢–µ—Å—Ç–æ–≤—ã–π —Å–∫—Ä–∏–ø—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ª–æ–≥–∏–∫–∏ –ø—Ä–æ—Ü–µ–¥—É—Ä –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏—è
 * –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: node test-vote-procedures.cjs
 */

const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

// –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –ª–æ–≥–∏–∫—É –∏–∑ vote.cjs
const calculateDecisionLogic = (totalParticipants, totalOnlineParticipants, votesFor, votesAgainst, votesAbstain, votesAbsent, conditions, resultIfTrue) => {
  console.log('üìä –í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ:', {
    totalParticipants,
    totalOnlineParticipants,
    votesFor,
    votesAgainst,
    votesAbstain,
    votesAbsent
  });

  const totalVotesCount = votesFor + votesAgainst + votesAbstain;

  const evaluateExpression = (elements) => {
    const stack = [];
    const operators = [];

    for (let i = 0; i < elements.length; i++) {
      const element = elements[i];
      const value = typeof element === 'string' ? element : element.value;
      const type = typeof element === 'string' ? 'select' : element.type;

      if (value === '(') {
        operators.push(value);
      } else if (value === ')') {
        while (operators.length > 0 && operators[operators.length - 1] !== '(') {
          const op = operators.pop();
          if (['–ò', '–ò–ª–∏', '–ò–Ω–∞—á–µ', '–ö—Ä–æ–º–µ', 'AND', 'OR'].includes(op)) {
            const b = stack.pop();
            const a = stack.pop();
            if (op === '–ò' || op === 'AND') stack.push(a && b);
            else if (op === '–ò–ª–∏' || op === 'OR') stack.push(a || b);
            else if (op === '–ò–Ω–∞—á–µ') stack.push(a !== b);
            else if (op === '–ö—Ä–æ–º–µ') stack.push(a && !b);
          } else if (['>', '<', '>=', '<=', '='].includes(op)) {
            const b = stack.pop();
            const a = stack.pop();
            if (op === '>') stack.push(a > b);
            else if (op === '>=') stack.push(a >= b);
            else if (op === '<') stack.push(a < b);
            else if (op === '<=') stack.push(a <= b);
            else if (op === '=') stack.push(a == b);
          } else {
            const b = stack.pop();
            const a = stack.pop();
            if (op === '*') stack.push(a * b);
            else if (op === '+') stack.push(a + b);
            else if (op === '-') stack.push(a - b);
            else if (op === '/') stack.push(a / b);
          }
        }
        operators.pop();
      } else if (['–ò', '–ò–ª–∏', '–ò–Ω–∞—á–µ', '–ö—Ä–æ–º–µ', 'AND', 'OR', '>', '<', '>=', '<=', '=', '*', '+', '-', '/'].includes(value)) {
        while (
          operators.length > 0 &&
          operators[operators.length - 1] !== '(' &&
          (
            (['–ò', '–ò–ª–∏', '–ò–Ω–∞—á–µ', '–ö—Ä–æ–º–µ', 'AND', 'OR'].includes(value) && ['>', '<', '>=', '<=', '=', '*', '+', '-', '/'].includes(operators[operators.length - 1])) ||
            (['>', '<', '>=', '<=', '='].includes(value) && ['*', '+', '-', '/'].includes(operators[operators.length - 1]))
          )
        ) {
          const op = operators.pop();
          if (['–ò', '–ò–ª–∏', '–ò–Ω–∞—á–µ', '–ö—Ä–æ–º–µ', 'AND', 'OR'].includes(op)) {
            const b = stack.pop();
            const a = stack.pop();
            if (op === '–ò' || op === 'AND') stack.push(a && b);
            else if (op === '–ò–ª–∏' || op === 'OR') stack.push(a || b);
            else if (op === '–ò–Ω–∞—á–µ') stack.push(a !== b);
            else if (op === '–ö—Ä–æ–º–µ') stack.push(a && !b);
          } else if (['>', '<', '>=', '<=', '='].includes(op)) {
            const b = stack.pop();
            const a = stack.pop();
            if (op === '>') stack.push(a > b);
            else if (op === '>=') stack.push(a >= b);
            else if (op === '<') stack.push(a < b);
            else if (op === '<=') stack.push(a <= b);
            else if (op === '=') stack.push(a === b);
          } else {
            const b = stack.pop();
            const a = stack.pop();
            if (op === '*') stack.push(a * b);
            else if (op === '+') stack.push(a + b);
            else if (op === '-') stack.push(a - b);
            else if (op === '/') stack.push(a / b);
          }
        }
        operators.push(value);
      } else {
        let numValue;
        if (value === '–í—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∑–∞—Å–µ–¥–∞–Ω–∏—è') {
          numValue = totalParticipants;
        } else if (value === '–í—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –æ–Ω–ª–∞–π–Ω') {
          numValue = totalOnlineParticipants;
        } else if (value === '–í—Å–µ–≥–æ –≥–æ–ª–æ—Å–æ–≤') {
          numValue = totalVotesCount;
        } else if (value === '–ó–∞') {
          numValue = votesFor;
        } else if (value === '–ü—Ä–æ—Ç–∏–≤') {
          numValue = votesAgainst;
        } else if (value === '–í–æ–∑–¥–µ—Ä–∂–∞–ª–∏—Å—å') {
          numValue = votesAbstain;
        } else if (value === '–ù–µ –≥–æ–ª–æ—Å–æ–≤–∞–ª–∏') {
          numValue = votesAbsent;
        } else if (type === 'input') {
          numValue = parseFloat(value);
        }
        stack.push(numValue);
      }
    }

    while (operators.length > 0) {
      const op = operators.pop();
      if (op === '(') continue;
      if (['–ò', '–ò–ª–∏', '–ò–Ω–∞—á–µ', '–ö—Ä–æ–º–µ', 'AND', 'OR'].includes(op)) {
        const b = stack.pop();
        const a = stack.pop();
        if (op === '–ò' || op === 'AND') stack.push(a && b);
        else if (op === '–ò–ª–∏' || op === 'OR') stack.push(a || b);
        else if (op === '–ò–Ω–∞—á–µ') stack.push(a !== b);
        else if (op === '–ö—Ä–æ–º–µ') stack.push(a && !b);
      } else if (['>', '<', '>=', '<=', '='].includes(op)) {
        const b = stack.pop();
        const a = stack.pop();
        if (op === '>') stack.push(a > b);
        else if (op === '>=') stack.push(a >= b);
        else if (op === '<') stack.push(a < b);
        else if (op === '<=') stack.push(a <= b);
        else if (op === '=') stack.push(a === b);
      } else {
        const b = stack.pop();
        const a = stack.pop();
        if (op === '*') stack.push(a * b);
        else if (op === '+') stack.push(a + b);
        else if (op === '-') stack.push(a - b);
        else if (op === '/') stack.push(a / b);
      }
    }

    return stack.pop();
  };

  let finalConditionMet = true;

  for (let blockIndex = 0; blockIndex < conditions.length; blockIndex++) {
    const conditionBlock = conditions[blockIndex];
    const elements = conditionBlock.elements;
    console.log(`\nüîç –ë–ª–æ–∫ ${blockIndex + 1}:`, elements);

    let condition1Met = evaluateExpression(elements);
    console.log(`   –†–µ–∑—É–ª—å—Ç–∞—Ç –±–ª–æ–∫–∞ ${blockIndex + 1}:`, condition1Met);

    let condition2Met = true;
    if (conditionBlock.operator && conditionBlock.elements2) {
      const elements2 = conditionBlock.elements2;
      console.log(`   –ë–ª–æ–∫ ${blockIndex + 1}.2:`, elements2);
      condition2Met = evaluateExpression(elements2);
      console.log(`   –†–µ–∑—É–ª—å—Ç–∞—Ç –±–ª–æ–∫–∞ ${blockIndex + 1}.2:`, condition2Met);

      if (conditionBlock.operator === "–ò" || conditionBlock.operator === "AND") {
        condition1Met = condition1Met && condition2Met;
      } else if (conditionBlock.operator === "–ò–ª–∏" || conditionBlock.operator === "OR") {
        condition1Met = condition1Met || condition2Met;
      } else if (conditionBlock.operator === "–ò–Ω–∞—á–µ") {
        condition1Met = condition1Met !== condition2Met;
      } else if (conditionBlock.operator === "–ö—Ä–æ–º–µ") {
        condition1Met = condition1Met && !condition2Met;
      }
    }

    if (blockIndex === 0) {
      finalConditionMet = condition1Met;
    } else {
      const prevOperator = conditions[blockIndex - 1].operator;
      if (prevOperator === "–ò" || prevOperator === "AND") {
        finalConditionMet = finalConditionMet && condition1Met;
      } else if (prevOperator === "–ò–ª–∏" || prevOperator === "OR") {
        finalConditionMet = finalConditionMet || condition1Met;
      } else if (prevOperator === "–ò–Ω–∞—á–µ") {
        finalConditionMet = finalConditionMet !== condition1Met;
      } else if (prevOperator === "–ö—Ä–æ–º–µ") {
        finalConditionMet = finalConditionMet && !condition1Met;
      }
    }
  }

  const decision = finalConditionMet ? resultIfTrue : (resultIfTrue === "–ü—Ä–∏–Ω—è—Ç–æ" ? "–ù–µ –ø—Ä–∏–Ω—è—Ç–æ" : "–ü—Ä–∏–Ω—è—Ç–æ");
  console.log('\n‚úÖ –ò—Ç–æ–≥–æ–≤–æ–µ —Ä–µ—à–µ–Ω–∏–µ:', decision);

  return decision;
};

// –¢–µ—Å—Ç–æ–≤—ã–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏
const runTests = async () => {
  console.log('\n===========================================');
  console.log('üß™ –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï –õ–û–ì–ò–ö–ò –ü–†–û–¶–ï–î–£–† –ì–û–õ–û–°–û–í–ê–ù–ò–Ø');
  console.log('===========================================\n');

  const procedures = await prisma.voteProcedure.findMany({
    where: { id: { in: [2, 3, 4] } },
    orderBy: { id: 'asc' }
  });

  console.log('üìã –ó–∞–≥—Ä—É–∂–µ–Ω–æ –ø—Ä–æ—Ü–µ–¥—É—Ä:', procedures.length);

  const tests = [
    // –ü—Ä–æ—Ü–µ–¥—É—Ä–∞ #2: –ë–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ –æ—Ç –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É—é—â–∏—Ö
    {
      name: '–¢–µ—Å—Ç #1: –ü—Ä–æ—Ü–µ–¥—É—Ä–∞ #2 - 5 –ó–ê 5 –ü–†–û–¢–ò–í (10 –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç)',
      procedureId: 2,
      totalParticipants: 38,
      totalOnlineParticipants: 10,
      votesFor: 5,
      votesAgainst: 5,
      votesAbstain: 0,
      votesAbsent: 0,
      expectedDecision: '–ù–µ –ø—Ä–∏–Ω—è—Ç–æ'
    },
    {
      name: '–¢–µ—Å—Ç #2: –ü—Ä–æ—Ü–µ–¥—É—Ä–∞ #2 - 3 –ó–ê 7 –ü–†–û–¢–ò–í (10 –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç)',
      procedureId: 2,
      totalParticipants: 38,
      totalOnlineParticipants: 10,
      votesFor: 3,
      votesAgainst: 7,
      votesAbstain: 0,
      votesAbsent: 0,
      expectedDecision: '–ù–µ –ø—Ä–∏–Ω—è—Ç–æ'
    },
    {
      name: '–¢–µ—Å—Ç #3: –ü—Ä–æ—Ü–µ–¥—É—Ä–∞ #2 - 6 –ó–ê 4 –ü–†–û–¢–ò–í (10 –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç)',
      procedureId: 2,
      totalParticipants: 38,
      totalOnlineParticipants: 10,
      votesFor: 6,
      votesAgainst: 4,
      votesAbstain: 0,
      votesAbsent: 0,
      expectedDecision: '–ü—Ä–∏–Ω—è—Ç–æ'
    },
    // –ü—Ä–æ—Ü–µ–¥—É—Ä–∞ #3: –ù–µ –º–µ–Ω–µ–µ 2/3 –æ—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ–≥–æ —á–∏—Å–ª–∞
    {
      name: '–¢–µ—Å—Ç #4: –ü—Ä–æ—Ü–µ–¥—É—Ä–∞ #3 - 25 –ó–ê 13 –ü–†–û–¢–ò–í (38 –≤—Å–µ–≥–æ)',
      procedureId: 3,
      totalParticipants: 38,
      totalOnlineParticipants: 38,
      votesFor: 25,
      votesAgainst: 13,
      votesAbstain: 0,
      votesAbsent: 0,
      expectedDecision: '–ù–µ –ø—Ä–∏–Ω—è—Ç–æ'
    },
    {
      name: '–¢–µ—Å—Ç #5: –ü—Ä–æ—Ü–µ–¥—É—Ä–∞ #3 - 26 –ó–ê 12 –ü–†–û–¢–ò–í (38 –≤—Å–µ–≥–æ)',
      procedureId: 3,
      totalParticipants: 38,
      totalOnlineParticipants: 38,
      votesFor: 26,
      votesAgainst: 12,
      votesAbstain: 0,
      votesAbsent: 0,
      expectedDecision: '–ü—Ä–∏–Ω—è—Ç–æ'
    },
    {
      name: '–¢–µ—Å—Ç #6: –ü—Ä–æ—Ü–µ–¥—É—Ä–∞ #3 - 19 –ó–ê 19 –ü–†–û–¢–ò–í (38 –≤—Å–µ–≥–æ)',
      procedureId: 3,
      totalParticipants: 38,
      totalOnlineParticipants: 38,
      votesFor: 19,
      votesAgainst: 19,
      votesAbstain: 0,
      votesAbsent: 0,
      expectedDecision: '–ù–µ –ø—Ä–∏–Ω—è—Ç–æ'
    },
    // –ü—Ä–æ—Ü–µ–¥—É—Ä–∞ #4: –ë–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ –æ—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ–≥–æ —á–∏—Å–ª–∞
    {
      name: '–¢–µ—Å—Ç #7: –ü—Ä–æ—Ü–µ–¥—É—Ä–∞ #4 - 19 –ó–ê 19 –ü–†–û–¢–ò–í (38 –≤—Å–µ–≥–æ)',
      procedureId: 4,
      totalParticipants: 38,
      totalOnlineParticipants: 38,
      votesFor: 19,
      votesAgainst: 19,
      votesAbstain: 0,
      votesAbsent: 0,
      expectedDecision: '–ù–µ –ø—Ä–∏–Ω—è—Ç–æ'
    },
    {
      name: '–¢–µ—Å—Ç #8: –ü—Ä–æ—Ü–µ–¥—É—Ä–∞ #4 - 20 –ó–ê 18 –ü–†–û–¢–ò–í (38 –≤—Å–µ–≥–æ)',
      procedureId: 4,
      totalParticipants: 38,
      totalOnlineParticipants: 38,
      votesFor: 20,
      votesAgainst: 18,
      votesAbstain: 0,
      votesAbsent: 0,
      expectedDecision: '–ü—Ä–∏–Ω—è—Ç–æ'
    },
    {
      name: '–¢–µ—Å—Ç #9: –ü—Ä–æ—Ü–µ–¥—É—Ä–∞ #4 - 30 –ó–ê 8 –ü–†–û–¢–ò–í (38 –≤—Å–µ–≥–æ)',
      procedureId: 4,
      totalParticipants: 38,
      totalOnlineParticipants: 38,
      votesFor: 30,
      votesAgainst: 8,
      votesAbstain: 0,
      votesAbsent: 0,
      expectedDecision: '–ü—Ä–∏–Ω—è—Ç–æ'
    },
    {
      name: '–¢–µ—Å—Ç #10: –ü—Ä–æ—Ü–µ–¥—É—Ä–∞ #4 - 18 –ó–ê 20 –ü–†–û–¢–ò–í (38 –≤—Å–µ–≥–æ)',
      procedureId: 4,
      totalParticipants: 38,
      totalOnlineParticipants: 38,
      votesFor: 18,
      votesAgainst: 20,
      votesAbstain: 0,
      votesAbsent: 0,
      expectedDecision: '–ù–µ –ø—Ä–∏–Ω—è—Ç–æ'
    },
  ];

  let passedTests = 0;
  let failedTests = 0;

  for (const test of tests) {
    console.log('\n' + '='.repeat(60));
    console.log(`üß™ ${test.name}`);
    console.log('='.repeat(60));

    const procedure = procedures.find(p => p.id === test.procedureId);
    if (!procedure) {
      console.error(`‚ùå –ü—Ä–æ—Ü–µ–¥—É—Ä–∞ #${test.procedureId} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!`);
      failedTests++;
      continue;
    }

    const actualDecision = calculateDecisionLogic(
      test.totalParticipants,
      test.totalOnlineParticipants,
      test.votesFor,
      test.votesAgainst,
      test.votesAbstain,
      test.votesAbsent,
      procedure.conditions,
      procedure.resultIfTrue
    );

    console.log('\nüìù –û–∂–∏–¥–∞–µ–º–æ–µ —Ä–µ—à–µ–Ω–∏–µ:', test.expectedDecision);
    console.log('üìù –§–∞–∫—Ç–∏—á–µ—Å–∫–æ–µ —Ä–µ—à–µ–Ω–∏–µ:', actualDecision);

    if (actualDecision === test.expectedDecision) {
      console.log('‚úÖ –¢–ï–°–¢ –ü–†–û–ô–î–ï–ù');
      passedTests++;
    } else {
      console.log('‚ùå –¢–ï–°–¢ –ü–†–û–í–ê–õ–ï–ù');
      failedTests++;
    }
  }

  console.log('\n' + '='.repeat(60));
  console.log('üìä –ò–¢–û–ì–ò –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–Ø');
  console.log('='.repeat(60));
  console.log(`‚úÖ –ü—Ä–æ–π–¥–µ–Ω–æ —Ç–µ—Å—Ç–æ–≤: ${passedTests}`);
  console.log(`‚ùå –ü—Ä–æ–≤–∞–ª–µ–Ω–æ —Ç–µ—Å—Ç–æ–≤: ${failedTests}`);
  console.log(`üìä –í—Å–µ–≥–æ —Ç–µ—Å—Ç–æ–≤: ${tests.length}`);
  console.log('='.repeat(60) + '\n');

  await prisma.$disconnect();
  process.exit(failedTests > 0 ? 1 : 0);
};

runTests().catch(console.error);
